Ruby on Rails
===============

Rails
	Some websites
		http://guides.rubyonrails.org/getting_started.html
		http://ruby.railstutorial.org/ruby-on-rails-tutorial-book
		http://guides.rubyonrails.org/	
	Definitions
		Web Application development Framework written in Ruby. Aims to make web develpment easier.
		Principles(philosophy)
			DRY - "Don't Repeat Yourself" 
			Convention over configuration: If everybody does in a way, it should be a pattern, then for basic operations, just follow the convention.
	How is the process
		http://www.decom.ufop.br/imobilis/wp-content/uploads/2012/07/rails2.png

	Install:
		Windows 1
			http://railsinstaller.org/
			This tool installs many applications:
				Ruby 1.9.3 : The language and its compiler.
				Rails 3.2: The framework Rails
				Bundler: To manage dependencies(like Maven, Gradle)  http://bundler.io/
					Tracks the application code and its rubygems it needs to run.
					Specify your dependencies in a Gemfile in your project's root:
					automates the intalation and matainance of gems in gemsets.
					source 'https://rubygems.org' 
					gem 'nokogiri' 
					gem 'rack', '~>1.1' 
					gem 'rspec', :require => 'spec'
				Git: To access the github and so on.
				Sqlite: Simple and local database.  Everything is saved in a file.
				TinyTDS:  Simple FreeTDS(Tabular Data Stream) for ruby.  Library that can includes a ODBC to access SQL Sever or Sybase.
					FreeTDS is very used by UNIX/Linux developers.
				Suporte do SQL Server
				DevKit Development Kit for C++ and Ruby.
		Other links	
			Good to use Sinatra.  Auto web container.  It is like spark or springboot.
			Another good IDE
				http://www.sublimetext.com/2
			And another famous IDE (SubMine) from jet brains.
				http://www.jetbrains.com/ruby/
			http://rubygems.org/
				Tool that goes to a community's gems host for ruby.  
				RubyGems is a package management framework for Ruby
				A GEM seems to be a kind a plugin or a package.
				
				To install: ruby setup.rb
				After:
					gem update --system  //Update to the latest RubyGems version
					gem build foo.gemspec //Build your gem
					gem push foo-1.0.0.gem //Deploy your gem instantly
			https://rvm.io/ (Ruby Version Manager)
				RVM is a command-line tool which allows you to easily install, manage, and work with multiple ruby environments from interpreters to sets of gems.
					Switches between different Rubies and GEM environments
					Seems the blunder can be integrated with RVM
					http://rvm.io/integration/bundler
					http://www.ginzametrics.com/blog/rvm-bundler-in-five-seconds/
		- Steps 
			Windows 1
				1 - Installs railsInstallar(in root)
				2 - Install rubygems
					Unzip and call ruby setup.rb
			Wdindws 2
				1 - Donwload rubyInstaller
				2 - Install rubygems
				3 - gem install rails
			Linux
				http://www.akitaonrails.com/2012/08/13/ruby-e-rails-no-ubuntu-12-04-lts-precise
				-pangolin
	Create a project, based on http://guides.rubyonrails.org/getting_started.html#hello-rails-bang
				- rails new blog
			run the server
				- rails server
			create the controler for welcome and index
				- rails generate controller welcome index  
				Then /config/routes.rb include the command
					- get "welcome/index"
				Uncomment bellow and the root became the page index.
					root to 'welcome#index'
				Include resources
					Resources are related to model.
					- resources :posts
					This resource is create in server a REST reference to be done.  
					It is necessary to create a controller
					Call: - rake routes
				Create the controller for post
					- rails g(or generate) controller posts
				If call http://localhost:3000/posts/new
					It will complain that no action "new" exists.
					Need to create a method
						def new
						end
				Create a file  app/views/posts/new.html.erb
					<%= form_for :post, url: posts_path do |f| %>
					  <p>
					    <%= f.label :title %><br>
					    <%= f.text_field :title %>
					  </p>
					 
					  <p>
					    <%= f.label :text %><br>
					    <%= f.text_area :text %>
					  </p>
					 
					  <p>
					    <%= f.submit %>
					  </p>
					<% end %>
						
	Creating a new application called gestbook
		- rails new gestbook
			Gemfile
				Contain all the dependencies.
				bundle install  //read this file and install all the dependencies
			Creates a application and install all the dependencies(gems).
		- About ignore files (.ignore)
			http://help.github.com/ignore-files/
		- cd gestbook
			Many directories and files are created, the most imprtant for developer is app/, because in this directory we find all files of controller, model, views, helpers.
		- bundle install
		OR
		- bundle install --without production  //run without production.

		-if there is a error: gem install uglifier
		
		- To run the rails: rails server.
		- Server is running, then, go to http://localhost:3000
			The following image appears.
			firstImageRails
		Builing a project

		My small project, guestbook will have this configuration:
			User -> name, email, webpage, title, aboutme
			Comment -> String comment, User user. belongsTo feedback
			Feedback -> title, feedback, User user, hasmany comments
	Another way to create projects (Passing -m get a template.)
			rails new myappTest -m https://raw.github.com/RailsApps/rails-composer/master/composer.rb
			An example of applications working with bootstrap
			https://github.com/RailsApps/rails-bootstrap/


	RVM
		RVM is a command line tool which allows us to easily install, manage and work with multiple ruby environments from interpreters to sets of gems
	Pik
		Pik is a version manager for Ruby. You can handle/install multiple versions of Ruby and switch between them easily.
		gem insatll pik
		pik_install C:\tools
		Add this to your Path Environmental variables

	To upgrade to rails 4
		gem install rails --version=4.0
	
	The inheritances
		Model
			http://ruby.railstutorial.org/images/figures/demo_model_inheritance.png
		Controller
			http://ruby.railstutorial.org/images/figures/demo_controller_inheritance.png

	git and rails
		Install
			$ sudo apt-get install git-core git-doc 
			$ sudo apt-get install gitweb git-gui gitk git-email git-svn
			sudo apt-get update

		$ git config --global user.name "Your Name"
		$ git config --global user.email your.email@example.com

		$ git config --global alias.co checkout   //just an alias called co from checkout.

		git config --global core.editor "subl -w"  //a default editor

		Inside the project
			git init
			git add .
			git commit -m “text
			git remote add origin https://github.com/romalopes/railsFirstApp.git
			git push -u origin master

			Branch
			$ git checkout -b New_Files
			$ git branch
			$ git branch -d New_Files  //to merge

	Heroku and rails
		https://devcenter.heroku.com/articles/getting-started-with-ruby
		Heroku works with PostgresQL
			- add a the declarations in Gemfile to be like the following
		GemFile
			source 'https://rubygems.org'
			ruby '2.0.0'
			#ruby-gemset=railstutorial_rails_4_0

			gem 'rails', '4.0.0'

			group :development do
			  gem 'sqlite3', '1.3.8'
			end

			gem 'sass-rails', '4.0.1'
			gem 'uglifier', '2.1.1'
			gem 'coffee-rails', '4.0.1'
			gem 'jquery-rails', '3.0.4'
			gem 'turbolinks', '1.1.1'
			gem 'jbuilder', '1.0.2'

			group :doc do
			  gem 'sdoc', '0.3.20', require: false
			end

			group :production do
			  gem 'pg', '0.15.1'
			  gem 'rails_12factor', '0.0.2'
			end

		Before deploy to heroku
			$ bundle install --without production
			$ bundle update
			$ bundle install

		Basic Commands básicos:
			$ heroku create
			$ git push heroku master
			$ heroku run rake db:migrate
			$ heroku open
			Running in http://railsfirstapproma.herokuapp.com/users

	MVC
	http://ruby.railstutorial.org/images/figures/mvc_detailed.png
	Problems of Scarffold:
		- No data validation
		- No authentication
		- No tests
		- No layout

#### A Simple application:
	Model
		User: id:integer, name:string, email:string, password:string
		micropost: id:integer, content:string, user_id:integer
	Creating Resources:
		Create a User scaffold
		$ rails generate scaffold User name:string email:string password:string
		$ bundle exec rake db:migrate OR JUST rake db:migrate
			What it does:
				Model(class User < ActiveRecord::Base)
				A variable @users is created in UsersController
		include -> resources :user in config/routes.rb

	Controler(class UsersController < ApplicationController)
		As it is scaffold fill the file to REST/CRUD.
		$ bundle exec rake db:migrate OR JUST rake db:migrate
		$bundle exec rake -T db list of tasks related to db


	Herroku
		$ heroku create
		$ git push heroku master
		$ heroku run rake db:migrate
		$ heroku open
		Running in http://railsfirstapproma.herokuapp.com/users
	

http://railsapps.github.io/installing-rails.html
http://www.psychocats.net/ubuntu/virtualbox



Sumary of guides.rubyonrails
=================

Active Record Basics

	It is the M from MVC

	Names convention
	Model/class 	Table/Schema
		Post 			posts 		
		LineItem 		line_items
		Deer 			deer
		Mouse 			mice

	Example of a class

		class
			 
			Product < ActiveRecord::Base
			 	self.table_name = "PRODUCT"   # Optional
				self.primary_key = "product_id" #Optional
			end

		Result in DB
			CREATE TABLE products (
				id int(11) 	NOT	NULL auto_increment,
				name varchar (255),
				PRIMARY KEY(id)
			);

	CRUD

	Create

		user = User.create(name: "David", occupation: "Code Artist")
		//with new object is created but not saved
	  	user = User.new do |u|
	  		u.name = "David"
	  		u.occupation = "Code Artist"
		end

	Read
		More:
		  http://guides.rubyonrails.org/active_record_querying.html

		# return a collection with all users
		users = User.all

		# return the first user
		user = User.first

		# return the first user named David
		david = User.find_by(name: 'David')

		# find all users named David who are Code Artists and sort by created_at in reverse chronological order
		users = User.where(name: 'David', occupation: 'Code Artist').order('created_at DESC')


	Update
		user = User.find_by(name: 'David')
		user.name = 'Dave'
		user.save

		user = User.find_by(name: 'David')
		user.update(name: 'Dave')

		User.update_all 
		"max_login_attempts = 3, must_change_password = 'true'"

	Delete
		user = User.find_by(name: 'David')
		user.destroy

	Validation
		http://guides.rubyonrails.org/active_record_validations.html
	  Ex:
		class
		 
		User < ActiveRecord::Base
		  
		     validates :name, presence: true
		end
	 
		User.create  
		# => false
		User.create! 
		# => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

	Callbacks
	  http://guides.rubyonrails.org/active_record_callbacks.html
	   Attach code to certain events in the life-cycle of your models.  Allows to include behavior to the model transparently executing code when some event happens.  Ex, when you create, update or delete a object.

	Migration
	http://guides.rubyonrails.org/migrations.html
	   Uses a DSL for managing a database schema.  Migration files are executed against any DB that Active Record supports using Rake
		Ex:
		class CreatePublications < ActiveRecord::Migration
		  
		  def change
		    
			create_table :publications do |t|
		      		t.string 	:title
		      		t.text 	 	:description
		      		t.references 	:publication_type
		      		t.integer 	:publisher_id
		      		t.string 	:publisher_type
		      		t.boolean 	:single_issue
		       
				t.timestamps
		    	end
		    	add_index :publications, :publication_type_id
		  end
		end
	Comands of rake
		rake db:drop
		rake db:resed
		rake db:migrate 

		rake db:populate
		 rake test:prepare


Rails Database Migration
	Use Ruby DSL(Domain Specific Language) instead of SQL
	File updated is  db/schema.rb
	Ex:
		class CreateProducts < ActiveRecord::Migration
		  def change
		    create_table :products do |t|
		      t.string :name
		      t.text :description
		 
		      t.timestamps
		    end
		  end
		end
		t.timestamps creates the columns created_at and updated_at.
	Creating the Migration 
		Command:
			$ rails generate migration  CommandClass
		Migrations are created in db/migrate as the name: 	
			YYYMMDDHHMMSS_NAME_CLASS(table).rb
		Ex:
			$ rails generate migration AddPartNumberToProducts
			generates in a file YYYMMDDHHMMSS_add_details_to_products.r:
				class AddPartNumberToProducts < ActiveRecord::Migration
				  def change
				  end
				end
		Use conventions:
			CreateXXX
				$ rails generate migration CreateProducts name:string part_number:string
				-generates:
					class CreateProducts < ActiveRecord::Migration
					  def change
					    create_table :products do |t|
					      t.string :name
					      t.string :part_number
					    end
					  end
					end
			AddXXXToYYY
				$ rails generate migration AddPartNumberToProducts part_number:string:index price:decimal
				generates:
					class AddPartNumberToProducts < ActiveRecord::Migration
					  def change
					    add_column :products, :part_number, :string
					    add_index :products, :part_number
					    add_column :products, :price, :decimal
					  end
					end

			RemoveXXXFromYYY
				$ rails generate migration RemovePartNumberFromProducts part_number:string
				-generates
					class RemovePartNumberFromProducts < ActiveRecord::Migration
					  def change
					    remove_column :products, :part_number, :string
					  end
					end
		Including reference to another Class
			$ rails generate migration AddUserRefToProducts user:references
			-generates
				class AddUserRefToProducts < ActiveRecord::Migration
				  def change
				    add_reference :products, :user, index: true
				  end
				end
			- This migration will create a user_id column and appropriate index.
		Joint table
			$ rails g migration CreateJoinTableCustomerProduct customer product
			-generates
				class CreateJoinTableCustomerProduct < ActiveRecord::Migration
				  def change
				    create_join_table :customers, :products do |t|
				      # t.index [:customer_id, :product_id]
				      # t.index [:product_id, :customer_id]
				    end
				  end
				end
	Model Generators
		When generates a model, rails will also generate a migration file 

		$ rails generate model Product name:string description:text
		- generates
			class CreateProducts < ActiveRecord::Migration
			  def change
			    create_table :products do |t|
			      t.string :name
			      t.text :description
			 
			      t.timestamps
			    end
			  end
			end
	Add Type modifier
		- limit Sets the maximum size of the string/text/binary/integer fields
		- precision Defines the precision for the decimal fields
		- scale Defines the scale for the decimal fields
		- polymorphic Adds a type column for belongs_to associations
		- null Allows or disallows NULL values in the column.
		Ex:
			$ rails generate migration AddDetailsToProducts price:decimal{5,2} supplier:references{polymorphic}
			- generates
				class AddDetailsToProducts < ActiveRecord::Migration
				  def change
				    add_column :products, :price, :decimal, precision: 5, scale: 2
				    add_reference :products, :supplier, polymorphic: true, index: true
				  end
				end
	Parts of Migration file
		Create table
			create_table :products, options: "ENGINE=BLACKHOLE" do |t|
			  t.string :name, null: false
			end
		Join Table
			create_join_table :products, :categories, column_options: {null: true}
				- Creates a new table categories_products with 2 columns(category_id, product_id) with the option that column can be null.
			create_join_table :products, :categories, table_name: :categorization
				- Set the name of the table_name
		Add Index which is not created by default
			create_join_table :products, :categories do |t|
			  t.index :product_id
			  t.index :category_id
			end
	Change Table
		Change table, including/removing/renaming and so on
		Ex:
			change_table :products do |t|
			  t.remove :description, :name  #remove column description and name
			  t.string :part_number  #Creates par_number column
			  t.index :part_number	#creates part_number index
			  t.rename :upccode, :upc_code 
			end
	Executing a SQL directry
		Products.connection.execute('UPDATE `products` SET `price`=`free` WHERE 1')
	Methods
		They can be used when the migration can be reverted
		add_column
		add_index
		add_reference
		add_timestamps
		create_table
		create_join_table
		drop_table (must supply a block)
		drop_join_table (must supply a block)
		remove_timestamps
		rename_column
		rename_index
		remove_reference
		rename_table
	Reversible
		Used in complex migrations where Active Records doesn't know to revese. Using reverse, it is possible to specify what to do in a migration.
		Ensure that the actions are executed in the right order.
	Up/Down methods
		Old style of migration intead of change method.
		Up
			should describe the transformation you'd like to make to your schema
		Down
			should revert the transformations done by the up method
		Ex:
			Create a table in up and delete it in down
	Running migration
		$ rake db:migrate VERSION=20080906120000

		rollback 3 steps
			$ rake db:rollback STEP=3
		roolback 3 steps and redo the migration
			$ rake db:migrate:redo STEP=3
		Reset database
			Drop the table, recreate and load the current schema
			$ rake db:reset
			- If a migrantion can't be rolledback, the command doesn't work.
		Running migration of different environment
			$ rake db:migrate RAILS_ENV=test
	Output
		say -> print a message
			say 'something'
		suppress_messages -> avoid any message in a block
			ppress_messages {add_index :products, :name}
    			say "and an index!", true
    	say_with_time
			Wait some time to say something.

Active Record Validation
	Validation happens when class.new_record? is called
	Ex:
		p = Person.new(name: "John Doe")
		#<Person id: nil, name: "John Doe", created_at: nil, updated_at: nil>
		#p.new_record?
		#true
		p.save
		#true
		p.new_reccord?
		false
	Validation acts on:
		create
		create!
		save
		save!
		update
		update!
	These methods skip validation
		decrement!
		decrement_counter
		increment!
		increment_counter
		toggle!
		touch
		update_all
		update_attribute
		update_column
		update_columns
		update_counters

		save(validate: false)
	valid? invalid?
		Person.create(name: nil).valid? # => false
	errors[]
		After validation, each error will be stores in a array object.errors
		Person.new.errors[:name].any?
		add
			It is possible to add error
			errors.add(:name, "cannot contain the characters !@#%*()_-+=")
		Clear and Empty
			person.errors.clear
			person.errors.empty? # => true
		size
			person.errors.size # => 2
		Each erro
			person.errors.full_messages.each do |msg| 
      			puts msg 
      		end
      	When a error occurs a <div> is created to b

Active Record Callbacks

Active Record Associations
	

Active Record Query Interface
	Ex:
		class Client < ActiveRecord::Base
		  has_one :address
		  has_many :orders
		  has_and_belongs_to_many :roles
		end
		class Address < ActiveRecord::Base
		  belongs_to :client
		end
		class Order < ActiveRecord::Base
		  belongs_to :client, counter_cache: true
		end
		class Role < ActiveRecord::Base
		  has_and_belongs_to_many :clients
		end
	Retrive object from Database.  These methods returns a instance of ActiveRecord::Relation
		bind
		create_with
		eager_load
		extending
		from
		group
		having
		includes
		joins
		limit
		lock
		none
		offset
		order
		preload
		readonly
		references
		reorder
		reverse_order
		select
		distinct
		uniq
		where

	Retrieving a single object
		find
			# Find the client with primary key (id) 10.
			client = Client.find(10)
			Executes: SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
		take
			#Return any record from table
			client = Client.take
			executes: SELECT * FROM clients LIMIT 1
		first
			#return the first record from table
			client = Client.first
			executes: SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
		last
			#return the last record from table
			client = Client.last
			executes: SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
		find_by
			Client.find_by first_name: 'Lifo'
			Equivalent to
				Client.where(first_name: 'Lifo').take
	Retrieving multiple objects
		find
			# Find the clients with primary keys 1 and 10.
			client = Client.find([1, 10])
			SELECT * FROM clients WHERE (clients.id IN (1,10))
		take
			#Take two record from table in any order
			Client.take(2)
			executes: SELECT * FROM clients LIMIT 2
		first
			#Return the two first records from table
			Client.first(2)
			execues: SELECT * FROM clients ORDER BY id ASC LIMIT 2
		last
			#Return tha two last records from table
			Client.last(2)
			executes: SELECT * FROM clients ORDER BY id DESC LIMIT 2
	Retrieving multiple objects in batch

	Conditions (Where)
		Ex:
			Client.where("orders_count = '2'")
			Client.where("orders_count = ? AND locked = ?", params[:orders], false)
			Client.where("orders_count = #{params[:orders]}") <- Insecure

		Placeholder conditions (use ":xxx" intead of "?")
			Client.where("created_at >= :start_date AND created_at <= :end_date", {start_date: params[:start_date], end_date: params[:end_date]})

		Hash conditions
			Client.where(locked: true)
			OR
			Client.where('locked' => true)
			With belongs_to relationship.  Passes the object of relationship
				Post.where(author: author)
				Author.joins(:posts).where(posts: {author: author})
			Range (Implements between) 
				Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
			Subset (Implements IN)
				Client.where(orders_count: [1,3,5])
				Executes: SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
		NOT condition
			Post.where.not(author: author)
		Order (none, :asc, :desc)
			Client.order(:created_at)
			# OR
			Client.order("created_at")
			#OR
			Client.order(orders_count: :asc, created_at: :desc)
		SELECT
			While "find" returns all fields.  SELECT returns only the specified
			Client.select("viewable_by, locked")
			executes: SELECT viewable_by, locked FROM clients
			If try to get an attribute that doesn't exists returns a error
				ActiveModel::MissingAttributeError: missing attribute: <attribute>
			DISTINCT
				Client.select(:name).distinct
				executes:
					select DISTINCT name from Client
		LIMITS
			Client.limit(5)
			OFFSET
				Client.limit(5).offset(30)
				executes: SELECT * FROM clients LIMIT 5 OFFSET 30
		GROUPBY
			Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
			executes: SELECT date(created_at) as ordered_date, sum(price) as total_price FROM orders GROUP BY date(created_at) 
		HAVING
			Specify a condition on Groupby
			
			Order.select("date(created_at) as ordered_date, sum(price) as total_price").  group("date(created_at)").having("sum(price) > ?", 100)
	Overrigind Conditions
		Except
		unscope
		only
		reorder
		reverse_order
	NULL Relation
		Post.none # => returning [] or nil breaks the caller code in this
	Readonly objects
		Disallow modification and raises ActiveRecord::ReadOnlyRecord exception
		client = Client.readonly.first
	Locking Records for Update
		Optimistic Locking
			Allows multiple users access the same record and edits it.  Assumes minimal conflict.  Checks if someone changed the data the record is open
			- Include a column lock_version of type integer.  When the record changes, Active Rercord increments lock_version.

			c1 = Client.find(1)
			c2 = Client.find(1)
			 
			c1.first_name = "Michael"
			c1.save
			 
			c2.name = "should fail"
			c2.save # Raises an ActiveRecord::StaleObjectError

		Pessimistic Locking
			Uses the mechanism provided by Database.  Get the exclusive lock on the selected rows
				Item.transaction do
				  i = Item.lock.first  # Lock the first
				  i.name = 'Jones'
				  i.save
				end
			#OR
				item = Item.first
				item.with_lock do
				  # This block is called within a transaction,
				  # item is already locked.
				  item.increment!(:views)
				end
			Can pass raw SQL to the lock method, allowing different types of lock
			Ex for MySQL
				Item.transaction do
				  i = Item.lock("LOCK IN SHARE MODE").find(1)
				  i.increment!(:views)
				end
	Joining Tables
		Just specify a SQL
			Returns the left table even it the right is NULL
			Client.joins('LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')
			executes: SELECT clients.* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id
		In the configuration:
			class Category < ActiveRecord::Base
			  has_many :posts
			end
			 
			class Post < ActiveRecord::Base
			  belongs_to :category
			  has_many :comments
			  has_many :tags
			end
			 
			class Comment < ActiveRecord::Base
			  belongs_to :post
			  has_one :guest
			end
			 
			class Guest < ActiveRecord::Base
			  belongs_to :comment
			end
			 
			class Tag < ActiveRecord::Base
			  belongs_to :post
			end

		Joining a Single Association (INNER)
			return a Category object for all categories with posts
			Category.joins(:posts)
			executes: SELECT categories.* FROM categories INNER JOIN posts ON posts.category_id = categories.id
		Joining Multiple Associations
			return all posts that have a category and at least one comment
			Post.joins(:category, :comments)
			Executes: SELECT posts.* FROM posts
				INNER JOIN categories ON posts.category_id = categories.id
				INNER JOIN comments ON comments.post_id = posts.id
		Joining Nested Associations (Single Level)
			return all posts that have a comment made by a guest.
			Post.joins(comments: :guest)
			executes: SELECT posts.* FROM posts
  				INNER JOIN comments ON comments.post_id = posts.id
  				INNER JOIN guests ON guests.comment_id = comments.id
  		Joining Nested Associations (Multiple Level)
  			Category.joins(posts: [{comments: :guest}, :tags])
			executes: SELECT categories.* FROM categories
			  INNER JOIN posts ON posts.category_id = categories.id
			  INNER JOIN comments ON comments.post_id = posts.id
			  INNER JOIN guests ON guests.comment_id = comments.id
			  INNER JOIN tags ON tags.post_id = posts.id
		Specifying Conditions on the Joined Tables
		 	- find all clients who have orders that were created yesterday, again using a BETWEEN SQL expression.
			time_range = (Time.now.midnight - 1.day)..Time.now.midnight
			Client.joins(:orders).where('orders.created_at' => time_range)
			OR
			time_range = (Time.now.midnight - 1.day)..Time.now.midnight
			Client.joins(:orders).where(orders: {created_at: time_range})
	Eager / Lazy loading
		# Includes the address in the select and don't read address in a different select(when it is doing put)
		clients = Client.includes(:address).limit(10)
 		clients.each do |client|
  			puts client.address.postcode
		end
		Two selects intead of 11.
			SELECT * FROM clients LIMIT 10
			SELECT addresses.* FROM addresses WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
		Eager for Multiple associations
			- This loads all the posts and the associated category and comments for each post.
			Post.includes(:category, :comments)
			- This will find the category with id 1 and eager load all of the associated posts, the associated posts' tags and comments, and every comment's guest association.
				Category.includes(posts: [{comments: :guest}, :tags]).find(1)
		Specifying Conditions on Eager Loaded Associations
			Post.includes(:comments).where("comments.visible" => true)
			Works like inner join
	Scopes
		Defines common used queries which can be referenced as methods
		class Post < ActiveRecord::Base
  			scope :published, -> { where(published: true) }
  			#OR
			def self.published
			    where(published: true)
			end
			# CAN CHAIN ex: using the scope published above
			scope :published_and_commented, -> { published.where("comments_count > 0") }

			#With arguments
			scope :created_before, ->(time) { where("created_at < ?", time) }
		end
		Call this ways
			Post.published # => [published posts]
			#OR
			category = Category.first
			category.posts.published # => [published posts belonging to this category]
		
			Post.created_before(Time.zone.now)

		Merge scopes
			class User < ActiveRecord::Base
			  scope :active, -> { where state: 'active' }
			  scope :inactive, -> { where state: 'inactive' }
			end
			Calling:			 
				User.active.inactive
				# => SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'
			Meging with where
				User.active.where(state: 'finished')
				# => SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'
		Applying a default scope
			To apply a scope in all queries - default_scope
				class Client < ActiveRecord::Base
				  default_scope { where("removed_at IS NULL") }
				end		
	Using SQL
		find_by_sql
			Just put the select inside the command
			Returns a list of objects
			Client.find_by_sql("SELECT * FROM clients
	  					INNER JOIN orders ON clients.id = orders.client_id
  						ORDER clients.created_at desc")
  		select_all
  			Returns a array of hashes
  			Client.connection.select_all("SELECT * FROM clients WHERE id = '1'")
  		pluck
  			Returns only the elements required.  Converts the database result in a Ruby Array.
  			Client.where(active: true).pluck(:id)
				# SELECT id FROM clients WHERE active = 1
				# => [1, 2, 3]
			 
			Client.distinct.pluck(:role)
				# SELECT DISTINCT role FROM clients
				# => ['admin', 'member', 'guest']
			 
			Client.pluck(:id, :name)
				# SELECT clients.id, clients.name FROM clients
				# => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
			- Pluck can't be chained.  Has to be the last command
				Client.pluck(:name).limit(1)
				# => NoMethodError: undefined method `limit' for #<Array:0x007ff34d3ad6d8>
				 
				Client.limit(1).pluck(:name)
				# => ["David"]
		ids
			Pluck all ids of a Table
			Person.ids
			# SELECT id FROM people
			Changing the primary key
				class Person < ActiveRecord::Base
				  self.primary_key = "person_id"
				end
				Person.ids
				# SELECT person_id FROM people
		Existence of a Object
			exists?			any?	many?
			Return true or false
			Client.exists?(1)
			Client.exists?([1,2,3])
			Client.where(first_name: 'Ryan').exists?
	Calculations
		Count
			Client.SELECT
			# count count(*) AS count_all FROM clients
			Client.where(first_name: 'Ryan').count
			# SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')
			Client.includes("orders").where(first_name: 'Ryan', orders: {status: 'received'}).count
			#SELECT count(DISTINCT clients.id) AS count_all FROM clients
						 LEFT OUTER JOIN orders ON orders.client_id = client.id 
						 WHERE (clients.first_name = 'Ryan' AND orders.status = 'received')
			Counts the clients that have age attribute
			Client(:age).count
		Average
			Client.average("orders_count")
		Minimum
			Client.minimum("age")
		Maximum
			Client.maximum("age")
		Sum
			Client.sum("orders_count")
	EXPLAIN
		Shows the SQL
		User.where(id: 1).joins(:posts).explain

			

